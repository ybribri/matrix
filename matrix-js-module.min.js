export class Matrix{"use strict";#t;constructor(t,i){null!=t&&null!=i&&(this.row=t,this.column=i,this.#t=Array.from({length:this.row},(()=>Array.from({length:this.column},(()=>null)))))}get value(){return this.#t}set value(t){Array.isArray(t)&&(this.#t=t,this.row=this.#t.length,this.column=this.#t[0].length)}getValueOf(t=[0,0]){const[i,r]=this.#i(t);if(!(i<0||i>this.row-1||r<0||r>this.#t[i].length-1))return this.#t[i][r]}setValueOf(t=[0,0],i){Array.isArray(t)||(i=t,t=[0,0]);const[r,e]=this.#i(t);if(!(r<0||e<0)){if(null!=i)return this.#t[r][e]=i,i;console.log("value is missing.")}}static isMatrix(t){return t instanceof this}fill(t=null,i=[0,0],r=[this.row-1,this.#t[this.row-1].length]){const[e,n]=this.#r(i),[s,h]=this.#e(r);if(e>this.row||e>s||s==e&&n>=h)return this.#t;if(s<0||h<0)return this.#t;for(let i=e;i<=s;i++)for(let r=i==e?n:0;r<(i==s?h:this.#t[i].length);r++)this.#t[i][r]="function"==typeof t?t(this.#t[i][r],[i,r],this.#t):t;let o=new Matrix(this.#t.length,this.#t[0].length);return o.value=this.#t,o}reverse(t="colrow"){t.includes("col")&&(this.#t=this.#t.map((t=>t.map(((i,r)=>t[t.length-1-r]))))),t.includes("row")&&(this.#t=this.#t.map(((t,i)=>this.#t[this.#t.length-1-i])));let i=new Matrix(this.#t.length,this.#t[0].length);return i.value=this.#t,i}sort(t,i="row"){if("col"!==i&&"row"!==i)return this.#t;if("col"==i&&(this.#t=this.#t.map((i=>i.sort(t)))),"row"==i){let i=this.#t.flat();i=i.sort(t);let r=[],e=[];i.forEach(((t,i)=>{r.push(t),(i+1)%this.#t[0].length==0&&(e.push(r),r=[])})),this.#t=e}return this}map(t,i){if(null==t)return void console.log("undefined is not a function");void 0!==i&&(t=t.bind(i));let r=this.#t.map(((i,r)=>i.map(((i,e)=>t(i,[r,e],this.#t))))),e=new Matrix(r.length,r[0].length);return e.value=r,e}filter(t,i){if(null==t)return void console.log("undefined is not a function");void 0!==i&&(t=t.bind(i));let r=this.#t.map(((i,r)=>i.map(((i,e)=>1==t(i,[r,e],this.#t)?i:null))));r=r.flat(2).filter((t=>null!==t));let e=[];if(r.length>0){let t=[];r.forEach(((i,n)=>{t.push(i),(n+1)%this.column!=0&&n!=r.length-1||(e.push(t),t=[])}))}let n=new Matrix(e.length,e[0].length);return n.value=e,n}forEach(t,i){null!=t?(void 0!==i&&(t=t.bind(i)),this.#t.forEach(((i,r)=>i.forEach(((i,e)=>t(i,[r,e],this.#t)))))):console.log("undefined is not a function")}flat(t=1){let i=new Matrix(this.#t.length,this.#t[0].length);return i.value=this.#t.map((i=>i.flat(t))),i}find(t,i){if(null!=t){void 0!==i&&(t=t.bind(i));for(let i=0;i<this.#t.length;i++)for(let r=0;r<this.#t[i].length;r++)if(!0===t(this.#t[i][r],[i,r],this.#t))return this.#t[i][r]}else console.log("undefined is not a function")}findIndex(t,i){if(null!=t){void 0!==i&&(t=t.bind(i));for(let i=0;i<this.#t.length;i++)for(let r=0;r<this.#t[i].length;r++)if(!0===t(this.#t[i][r],[i,r],this.#t))return[i,r];return[-1,-1]}console.log("function is missing.")}findLast(t,i){if(null!=t){void 0!==i&&(t=t.bind(i));for(let i=this.#t.length-1;i>=0;i--)for(let r=this.#t[i].length-1;r>=0;r--)if(!0===t(this.#t[i][r],[i,r],this.#t))return this.#t[i][r]}}findLastIndex(t,i){void 0!==i&&(t=t.bind(i));for(let i=this.#t.length-1;i>=0;i--)for(let r=this.#t[i].length-1;r>=0;r--)if(!0===t(this.#t[i][r],[i,r],this.#t))return[i,r];return[-1,-1]}indexOf(t,i=[0,0]){if(null==t)return[-1,-1];const[r,e]=this.#r(i);if(r>this.row-1)return[-1,-1];for(let i=r;i<this.#t.length;i++)for(let n=i==r?e:0;n<this.#t[i].length;n++)if(this.#t[i][n]===t)return[i,n];return[-1,-1]}lastIndexOf(t,i=[this.row-1,this.#t[this.row-1].length-1]){if(null==t)return[-1,-1];const[r,e]=this.#n(i);if(r<0)return[-1,-1];for(let i=r;i>=0;i--)for(let n=i==r?e:this.#t[i].length-1;n>=0;n--)if(this.#t[i][n]===t)return[i,n];return[-1,-1]}includes(t,i=[0,0]){if(null==t)return!1;const[r,e]=this.#r(i);if(r>this.row-1)return!1;for(let i=r;i<this.#t.length;i++)for(let n=i==r?e:0;n<this.#t[i].length;n++)if(this.#t[i][n]===t)return!0;return!1}at(t=[0,0]){let[i,r]=this.#i(t);if(!(i>this.row-1||i<0))return this.#t[i][r]}join(t=","){return this.#t.map((i=>i.join(t))).join(t)}concat(){let t,i,r=JSON.parse(JSON.stringify(this.#t));switch(arguments[arguments.length-1]){case"col":if(1==arguments.length)break;t=r[0].length,i=0,r.forEach(((r,e)=>{t>r.length&&(t=r.length,i=e)}));for(let t=0;t<arguments.length-1;t++){let e=arguments[t];if(Matrix.isMatrix(e)&&(e=e.value),Array.isArray(e)||1!=!e[Symbol.isConcatSpreadable])for(let t=0;t<e.length;t++)Array.isArray(e[t])?(r[i]=i>r.length?[...e[t]]:[...r[i],...e[t]],i++,i=i>this.row-1?0:i):(r[i]=i>r.length?[e[t]]:[...r[i],e[t]],i++,i=i>this.row-1?0:i);else r[i]=[...r[i],e],i++,i=i>this.row-1?0:i}break;default:r=r.flat(2);for(let t=0;t<arguments.length;t++){let i=arguments[t];if(Matrix.isMatrix(i)&&(i=i.value),Array.isArray(i)||1!=!i[Symbol.isConcatSpreadable])for(let t=0;t<i.length;t++)r=Array.isArray(i[t])?[...r,...i[t]]:[...r,i[t]];else r=[...r,i]}r=this.#s(r)}let e=new Matrix(r.length,r[0].length);return e.value=r,e}pop(){if(0==this.#t.length)return;let t="",i=[];return this.#t.forEach(((r,e)=>{e==this.row-1&&r.forEach(((i,e)=>{e==r.length-1&&(t=r.pop())})),r.length>0&&i.push(r)})),this.#t=i,this.row=this.#t.length,0==this.row?this.column=0:this.column=this.#t[0].length,t}push(){if(0!=arguments.length){for(let t=0;t<arguments.length;t++)this.#t[this.row-1].push(arguments[t]);return this.#t=this.#s(this.#t),this.row=this.#t.length,this.column=this.#t[0].length,this.#t[this.#t.length-1].length}}shift(){if(0==this.#t.length||0==this.#t[0].length)return;let t=this.#t[0].shift();return this.#t=this.#s(this.#t),this.row=this.#t.length,this.column=this.#t[0].length,t}unshift(t){if(null!=t)return this.#t[0].unshift(t),this.#t=this.#s(this.#t),this.row=this.#t.length,this.column=this.#t[0].length,this.#t[this.#t.length-1].length}slice(t=[0,0],i=[this.row-1,this.column],r="col"){const[e,n]=this.#r(t);let[s,h]=this.#e(i),o=[],l=[];switch(r){case"col":if(e>this.row-1||e>s||e==s&&n>=h)return[];if(s<0&&h<0)return[];for(let t=0;t<this.row;t++){let i=this.#t[t];if(!(t<e||t>s))for(let r=0;r<i.length;r++){let l=i[r];t==e&&r<n||(t==s&&r>=h||o.push(l))}}l=this.#s(o);break;case"row":if([s,h]=this.#h(i),n>this.column-1||n>h||n==h&&e>=s)return[];if(h<0&&s<0)return[];for(let t=0;t<this.column;t++)if(!(t<n||t>h))for(let i=0;i<this.row&&!(void 0===this.#t[i]||t==h&&i>=s);i++)o.push(this.#t[i][t]);l=this.#o(o)}let a=new Matrix(l.length,l[0].length);return a.value=l,a}splice(){if(null==arguments[0])return[];if(!Array.isArray(arguments[0]))return[];if(2!=arguments[0].length)return[];let[t,i]=this.#r(arguments[0]),r=null==arguments[1]?this.row*this.column:arguments[1],e=[];if(r>0&&t<=this.row-1)for(let n=0;n<r&&(i>this.#t[t].length-1&&(t++,i=0),!(t>this.#t.length-1||t==this.#t.length-1&&i>this.#t[t].length-1));n++)e.push(this.#t[t][i]),this.#t[t][i]="!!ToBeRemovedSoon!!",i++;let n=this.#t.flat().filter((t=>"!!ToBeRemovedSoon!!"!==t));[t,i]=this.#r(arguments[0]);let s=1==this.row?i:t*this.column+i;if(void 0!==arguments[2]&&s<n.length-1)for(let t=2;t<arguments.length;t++){let i=arguments[t];n.splice(s+t-2,0,i)}return this.#t=this.#s(n),this.row=this.#t.length,this.column=this.#t[0].length,e}every(t,i){void 0!==i&&(t=t.bind(i));for(let i=0;i<this.#t.length;i++)for(let r=0;r<this.#t[i].length;r++)if(!1===t(this.#t[i][r],[i,r],this.#t))return!1;return!0}some(t,i){void 0!==i&&(t=t.bind(i));for(let i=0;i<this.#t.length;i++)for(let r=0;r<this.#t[i].length;r++)if(!0===t(this.#t[i][r],[i,r],this.#t))return!0;return!1}reduce(t,i){let r,e,n=0;if(0!=this.#t.flat(2).length){null==i?(n=1,e=this.#t[0][0]):e=i;for(let i=0;i<this.#t.length;i++)for(let s=0==i?n:0;s<this.#t[i].length;s++)r=t(e,this.#t[i][s],[i,s],this.#t),e=r;return r}}reduceRight(t,i){let r,e,n=this.#t[this.row-1].length-1,s=this.row-1;if(0!=this.#t.flat(2).length){if(null==i){if(n=this.#t[s].length-2,n<0){if(s--,s<0)return this.#t[this.row-1][this.column-1];n=this.#t[s].length-1}e=this.#t[0][0]}else e=i;for(let i=s;i>=0;i--)for(let h=i==s?n:this.#t[i].length-1;h>=0;h--)r=t(e,this.#t[i][h],[i,h],this.#t),e=r;return r}}values(){return function*(){for(let t=0;t<this.row;t++)for(let i=0;i<this.#t[t].length;i++)yield this.#t[t][i]}.bind(this)()}entries(){return function*(){for(let t=0;t<this.row;t++)for(let i=0;i<this.#t[t].length;i++)yield[[t,i],this.#t[t][i]]}.bind(this)()}keys(){return function*(){for(let t=0;t<this.row;t++)for(let i=0;i<this.#t[t].length;i++)yield[t,i]}.bind(this)()}toString(){return this.#t.toString()}copyWithin(t=[0,0],i=[0,0],r=[this.row-1,this.#t[this.row-1].length]){if((t=this.#r(t))[0]>this.row-1)return this;if((i=this.#r(i))[0]>this.row-1)return this;r=this.#e(r);let e=1==this.row?t[1]:t[0]*this.column+t[1],n=1==this.row?i[1]:i[0]*this.column+i[1],s=1==this.row?r[1]:r[0]*this.column+r[1],h=this.#t.flat().copyWithin(e,n,s),o=[];if(h.length>0){let t=[];h.forEach(((i,r)=>{t.push(i),(r+1)%this.column!=0&&r!=h.length-1||(o.push(t),t=[])}))}return this.#t=o,this}transpose(){if(1==this.row&&0==this.column)return;let t=this.#t[0].length;if(!this.#t.every((i=>i.length===t)))return void console.warn("error : this matrix is not appropriate to be transposed.");let i=new Matrix(this.column,this.row);for(let t=0;t<this.row;t++)for(let r=0;r<this.#t[t].length;r++)i.setValueOf([r,t],this.#t[t][r]);return i}det(){if(1==this.row&&0==this.column)return;if(this.#t.every((t=>t.length===this.column))&&this.column===this.row)return this.#l(this);console.warn("error : a matrix should be a square to have a determinant.")}cofactors(){if(1==this.row&&0==this.column)return;if(!this.#t.every((t=>t.length===this.column))||this.column!==this.row)return void console.warn("error : a matrix should be a square to have matrix of cofactors.");let t=new Matrix(this.row,this.column);if(1==this.row)return t.value=[[1]],t;if(2==this.row)return t.value=[[this.getValueOf([1,1]),-this.getValueOf([1,0])],[-this.getValueOf([0,1]),this.getValueOf([0,0])]],t;for(let i=0;i<this.row;i++)for(let r=0;r<this.row;r++){let e=new Matrix(this.row,this.column);e.value=JSON.parse(JSON.stringify(this.#t));for(let t=0;t<this.row;t++)e.setValueOf([i,t],"toBeRemoved"),e.setValueOf([t,r],"toBeRemoved");let n=e.filter((t=>"toBeRemoved"!==t)).value;n=n.flat();let s=[],h=[];e.row--,e.column--,n.forEach(((t,i)=>{h.push(t),(i+1)%e.column!=0&&i!=n.length-1||(s.push(h),h=[])})),e.value=JSON.parse(JSON.stringify(s)),t.setValueOf([i,r],this.#l(e)*Math.pow(-1,i+r+2))}return t}adjoint(){if(1==this.row&&0==this.column)return;if(!this.#t.every((t=>t.length===this.column))||this.column!==this.row)return void console.warn("error : a matrix should be a square to have adjoint matrix.");return this.cofactors().transpose()}inverse(){if(1==this.row&&0==this.column)return;if(!this.#t.every((t=>t.length===this.column))||this.column!==this.row)return void console.warn("error : this matrix is not invertible. should be a square.");if(0===this.det())return void console.warn("error : this matrix is not invertible.");let t=this.det();return this.adjoint().map((i=>i/t))}add(t){if(1==this.row&&0==this.column)return;if(!Matrix.isMatrix(t))return void console.warn("error: argument is not a matrix.");if(!t.every(((t,[i,r])=>void 0!==this.getValueOf([i,r])))||this.row!==t.row||this.column!==t.column)return void console.warn("error: the size of the matrix is not matched.");let i=new Matrix(this.row,this.column);return i=t.map(((t,[i,r])=>t+this.getValueOf([i,r]))),i}subtract(t){if(1==this.row&&0==this.column)return;if(!Matrix.isMatrix(t))return void console.warn("error: argument is not a matrix.");if(!t.every(((t,[i,r])=>void 0!==this.getValueOf([i,r])))||this.row!==t.row||this.column!==t.column)return void console.warn("error: the size of the matrix is not matched.");let i=new Matrix(this.row,this.column);return i=t.map(((t,[i,r])=>this.getValueOf([i,r])-t)),i}multiply(t){if(1==this.row&&0==this.column)return;if(!Matrix.isMatrix(t)&&"number"!=typeof t)return void console.warn("error: argument has to be a matrix or a number.");if("number"==typeof t)return this.map((i=>i*t));let i=this.column;if(!this.#t.every((t=>t.length===i)))return void console.warn("error : existing matrix is not appropriate to be multiplied. not even column sizes.");if(i=t.column,!t.value.every((t=>t.length===i)))return void console.warn("error : multiplying matrix is not appropriate. not even column sizes.");if(this.column!==t.row)return void console.warn("error : column size of existing matrix has to be the same with row size of applying matrix.");let r=new Matrix(this.row,t.column);for(let i=0;i<t.column;i++)for(let e=0;e<this.row;e++){let n=0;for(let r=0;r<this.column;r++)n+=this.getValueOf([e,r])*t.getValueOf([r,i]);r.setValueOf([e,i],n)}return r}divide(t){if(1==this.row&&0==this.column)return;if(!Matrix.isMatrix(t)&&"number"!=typeof t)return void console.warn("error: argument has to be a matrix or a number.");if("number"==typeof t)return 0===t?void console.warn("error: cannot divide by 0."):this.map((i=>i/t));let i=this.column;if(!this.#t.every((t=>t.length===i)))return void console.warn("error : existing matrix is not appropriate to be divided. not even column sizes.");if(i=t.column,!t.value.every((t=>t.length===i)))return void console.warn("error : multiplying matrix is not appropriate. not even column sizes.");if(this.column!==t.row)return void console.warn("error : column size of existing matrix has to be the same with row size of applying matrix.");if(t.row!==t.column)return void console.warn("error : a divisor matrix should be a square.");if(0===t.det())return void console.warn("error : the determinant of a divisor matrix should not be 0.");let r=t.inverse();return this.multiply(r)}#l(t){if(1===t.column)return t.getValueOf([0,0]);if(2===t.column)return t.getValueOf([0,0])*t.getValueOf([1,1])-t.getValueOf([0,1])*t.getValueOf([1,0]);let i=0,r=new Matrix(t.row,t.column);for(let e=0;e<t.column;e++){r.value=JSON.parse(JSON.stringify(t.value));for(let t=0;t<r.column;t++)r.setValueOf([0,t],"toBeRemoved"),r.setValueOf([t,e],"toBeRemoved");let n=r.filter((t=>"toBeRemoved"!==t)).value;n=n.flat();let s=[],h=[];r.row--,r.column--,n.forEach(((t,i)=>{h.push(t),(i+1)%r.column!=0&&i!=n.length-1||(s.push(h),h=[])})),r.value=JSON.parse(JSON.stringify(s)),i+=t.getValueOf([0,e])*this.#l(r)*Math.pow(-1,e)}return i}#i(t){let[i,r]=t;return i=i<0?this.row+i:i,r=r<0?this.column+r:r,[i,r]}#r(t){let[i,r]=t;return i=i<0?this.row+i:i,i=i<0?0:i,r<0&&(r=this.#t[i].length+r),r=r<0?0:r,i==this.row-1&&r>this.#t[i].length-1&&(i=this.row),i<this.row-1&&r>this.column-1&&(i++,r=0),[i,r]}#n(t){let[i,r]=t;return i=i<0?this.row+i:i,i=i>this.row-1?this.row-1:i,r<0&&(r=this.#t[i].length+r),r=r>this.#t[i].length-1?this.#t[i].length-1:r,0==i&&r<0&&(i=-1),i>0&&r<0&&(i--,r=this.#t[i].length-1),[i,r]}#e(t){let[i,r]=t;return i<0&&(i=this.row+i),i=i>this.row-1?this.row-1:i,r<0&&(r=this.#t[i].length+r),r=r>this.#t[i].length?this.#t[i].length:r,0==i&&r<1&&(i=-1),i>0&&r<=0&&(i--,r=this.#t[i].length),[i,r]}#h(t){let[i,r]=t;return i<0&&(i=this.row+i),i=i>this.row?this.row:i,r<0&&(r=this.column+r),r=r>this.column-1?this.column-1:r,0==r&&i<1&&(r=-1),r>0&&i<=0&&(r--,i=this.#t.length),[i,r]}#s(t){t=t.flat();let i=[],r=[];return t.forEach(((e,n)=>{r.push(e),(n+1)%this.column!=0&&n!=t.length-1||(i.push(r),r=[])})),i}#o(t){t=t.flat();let i=[],r=0;for(let e=0;e<Math.ceil(t.length/this.row);e++)for(let n=0;n<this.row&&!(r>t.length-1);n++)0==e&&(i[n]=[]),i[n][e]=t[r],r++;return i}}